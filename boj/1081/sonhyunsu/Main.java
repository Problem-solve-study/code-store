//제출번호: 93400450
//메모리:   11532 KB
//실행시간: 68 ms
import java.io.*;

//[a, b]를 받으면 [0, b] - [0, a-1]을 이용해 결과 계산
//이 때 a-1이 -1이 되지 않도록 주의해야 함

//먼저 0~9, 0~99, 0~999, ..., 0~999999999 의 자릿수의 합을 모두 계산함
//그리고 0, 0~1, 0~2, ..., 0~9 의 합도 모두 계산함

//첫 번째 자릿수의 합를 계산하는 방법은 다음과 같음
//예를 들어서 0~99999 자릿수의 합을 구한다고 가정해보자
//이 때 앞의 1자리와 뒤의 4자리를 끊어서 확인해보자
//잘 확인해보면 0이 1만번, 1이 1만번, 2가 1만번, ..., 9가 1만번 나오고
//뒤의 4자리는 0000~9999가 반복됨을 알 수 있음
//그래서 0~99999 자릿수의 합은 = (0~9999 자릿수의 합) * 10 + (0~9의 합) * 10000 이 됨

//한 번 0~999999 자릿수의 합도 한 번 계산해보자
//앞의 1자리와 뒤의 5자리를 끊어서 확인해보면
//0이 10만번, 1이 10만번, ..., 9가 10만번 나오고
//뒤의 5자리는 00000~99999가 반복됨
//그래서 0~999999 자릿수의 합은 = (0~99999 자릿수의 합) * 10 + (0~9의 합) * 100000 이 됨

//dp[i]: 0~10^i-1번째 자릿수까지의 합
//dp[0] = 0;
//dp[i] = dp[i-1] * 10 + 45 * 10 ^ i
//하지만 여기에서는 1번째 자리를 0으로 잡음



//그리고 [0, x] 사이의 자릿수의 합을 구하는 방법도 예시를 들어서 설명해봄
//예를 들어 [0, 12345] 사이의 자릿수의 합을 구해보면

//[0, 12345]는 [0, 9999] + [10000, 12345] 로 나눌 수 있음
//[10000, 12345]는 1 * (2345 + 1) + [0000, 2345]와 값이 동일함

//[0, 2345]는 [0, 999] + [1000, 1999] + [2000, 2345]로 나눌 수 있음
//[1000, 1999]는 1 * 1000 + [000, 999]와 값이 동일함
//[2000, 2345]는 2 * (345 + 1) + [000, 345]와 동일함
//따라서 [0, 2345]는 2 * [0, 999] + (0~1의 합) * 1000 + 2 * (345 + 1) + [000, 345]로 나타낼 수 있음

//[0, 345]는 [0, 99] + [100, 199] + [200, 299] + [300, 345] 로 나눌 수 있음
//[0, 99] + [100, 199] + [200, 299] 는 3 * [0, 99] + (0~2의 합) * 100 으로 나타낼 수 있음
//[300, 345]는 3 * (45 + 1) + [00, 45]로 나타낼 수 있음
//따라서 [0, 345]는 3 * [0, 99] + (0~2의 합) * 100 + 3 * (45 + 1) + [0, 45]로 표현할 수 있음

//잘 보면 현재 자릿수를 n이라고 하고, 자릿수의 값을 x라고 하고, 원본 수를 a라고 할 때
//x * [0, 10^n - 1] + (0~x-1의 합) * 10^n + x * ((a % 10^n) + 1) 형태로 반복됨을 알 수 있다
public class Main {
    
    static StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    static long[] digitSum = new long[10];
    static int[] sum = new int[10];

    public static void main(String[] args) throws IOException {
        digitSum[0] = 45;
        for (int i = 1, j = 10; i < 10; i++, j *= 10) {
            digitSum[i] = digitSum[i - 1] * 10 + 1L * j * 45;
            sum[i] = sum[i - 1] + i;
        }

        int a = Math.max(nextInt() - 1, 0);
        int b = nextInt();

		//[0, b] - [0, max(a-1, 0)]
        System.out.print(getDigitSum(b) - getDigitSum(a));
    }

    static long getDigitSum(int x) {
		//일의 자리를 계산하고, s에 담음
        int prev = x % 10; x /= 10;
        long s = sum[prev];

		//십의 자리부터 올라가면서 계산
        for (int i = 1, j = 10; x > 0; i++, x /= 10, j *= 10) {
            int val = x % 10; //자릿수 값을 가져옴

			//이전 자릿수 [0, 99..] 형태가 반복된 개수만큼 곱함
            s += digitSum[i - 1] * val;

			//만약 0보다 크다면 
            if (val > 0) {
				//0 ~ val-1 의 합과 10^n을 곱한 값을 저장 
                s += 1L * sum[val - 1] * j;
            }

			//현재 자릿수의 값이 등장한 개수만큼(0 ~ prev 만큼 등장) val과 곱해서 저장
            s += 1L * (prev + 1) * val;

			//prev 업데이트 (현재 자릿수는 다음의 이전 자릿수가 될 것이므로)
            prev += j * val;
        }

        return s;
    }

    static int nextInt() throws IOException {
        st.nextToken();
        return (int) st.nval;
    }
}