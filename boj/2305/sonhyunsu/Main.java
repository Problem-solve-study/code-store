//제출번호: 91850486
//메모리:   11516 KB
//실행시간: 64 ms
import java.io.*;

//dp식을 찾는게 너무 오래 걸린 문제, 자유석이 중간에 있거나 양 끝에 있는 경우로 크게 분리될 수 있음
//자유석이 양 끝에 있는 경우에는 자유석을 아예 없다고 가정하고 연속된 좌석에 배치를 잘 하면 됨
//자유석이 가운데 있는 경우에는 건너뛰는 로직이 필요함
//자유석에 배치하는 경우는 따로 계산할 것이므로, 중복 계산되지 않도록 하기 위함

/*
 * dp[자유석 사용 여부][좌석 사용 비트(00, 01, 10, 11)][i]]:
 *   i번을 기준으로 (i+1, i) 좌석의 사용 여부, 자유석 사용 여부가 정해졌을 때 경우의 수 저장
 * 자세한 dp 전개 방식은 아래 코드에서 자세하게 설명
 * 그리고 dp는 수집하는 방식이 아니라, 전파하는 방식으로 경우의 수를 계산 했음
 * 수집 방식: dp[n] = dp[n - 1] + dp[n - 2] ...
 * 전파 방식: d[n + 1] += dp[n], dp[n + 2] += dp[n] ...
 */
public class Main {
    
    static StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    
	public static void main(String[] args) throws IOException {
	    int n = nextInt();
	    int k = nextInt();
	    long[][][] dp = new long[2][4][n + 2];
	    
		//만약 자유석 위치가 첫 번째라면 dp 시작은 2부터
	    int start = k == 1 ? 2 : 1;
	    dp[0][1][start] = dp[0][2][start] = dp[1][0][start] = 1;
	   
	    for (int i = 1; i <= n; i++) {
			//자유석은 배치하지 않음
    	    if (i == k) {
    	        continue;
    	    }
			//만약 다음 위치가 자유석이라면
			else if (i + 1 == k) {
				//이미 자유석을 사용한 경우와 아직 사용하지 않은 경우에 대해서 각각 계산
    	        for (int used = 0; used < 2; used++) {
					//i 시점에서 i + 1 좌석은 자유석이기 때문에 i + 1 좌석을 사용하지 않은 경우만 더해야 함
					//그리고 i번째 좌석의 사용 유무는 i + 2 시점에서 배치할 때 영향이 없기 때문에
					//i + 2 숫자는 i + 3, i + 2 중 아무 곳에나 배치할 수 있음
					//i + 2 숫자를 i + 2에 배치 == 01 배치
					//i + 2 숫자를 i + 3에 배치 == 10 배치
    	            dp[used][1][i + 2] += dp[used][0][i] + dp[used][1][i];
    	            dp[used][2][i + 2] += dp[used][0][i] + dp[used][1][i];
    	        }
				//i + 2 숫자를 자유석에 배치하는 경우를 계산
				//i + 2 숫자를 자유석에 배치하기 위해서는 i 숫자까지 자유석을 사용하지 않아야 함
				//그리고 i + 1 좌석은 자유석이기 때문에 i 숫자 기준으로 i + 1 좌석을 사용하지 않은 경우만 더해야 함
    	        dp[1][0][i + 2] += dp[0][0][i] + dp[0][1][i];
    	    } else {
				//나머지는 i + 1번째 좌석에 i 숫자를 배치할 수 있는 경우들임
				//이미 자유석을 사용한 경우와 아직 사용하지 않은 경우에 대해서 각각 계산
    	        for (int used = 0; used < 2; used++) {
					//i + 1번째와 i + 2번째 좌석을 사용하지 않고 i + 1 숫자를 배치하는 방법은
					//i번째 좌석에 i + 1 숫자를 배치하는 경우임.
					//그래서 i 숫자를 기준으로 i번째와 i + 1번째 좌석을 사용하지 않은 경우를 더함
    	            dp[used][0][i + 1] += dp[used][0][i];

					//i + 1번째 좌석만 사용하면서 i + 1 숫자를 배치하는 방법은
					//i + 1 숫자를 i 좌석 또는 i + 1 좌석에 배치하는 경우임
					//그래서 i 숫자를 기준으로 i + 1을 사용하면서 i 좌석이 비어 있는 경우나 i + 1 좌석이 비어 있는 경우만 더함
    	            dp[used][1][i + 1] += dp[used][0][i] + dp[used][1][i] + dp[used][2][i];

					//i + 2 번째 좌석만 사용하면서 i + 1 숫자를 배치하는 방법은
					//i + 1 숫자를 i + 2에 배치하면서 i 숫자 기준으로 i + 1 좌석을 사용하지 않는 경우임
					//그래서 i 숫자 기준으로 i + 1 좌석이 비어 있는 경우만 더함
    	            dp[used][2][i + 1] += dp[used][0][i] + dp[used][1][i];

					//i + 1, i + 2 좌석 모두 사용하면서 i + 1 숫자를 배치하는 방법은
					//i + 2 좌석에 i + 1 숫자를 배치하면서 i 숫자를 기준으로 i + 1 번째 좌석에 이미 어떤 수가 저장되어 있는 경우임
					//그래서 i 숫자 기준으로 i + 1 좌석을 사용하는 경우만 더함
    	            dp[used][3][i + 1] += dp[used][2][i] + dp[used][3][i];
    	        }

				//i + 1 숫자를 자유석에 배치하는 경우를 계산
				//i + 1 숫자를 자유석에 배치하면 i 숫자 기준으로 사용한 좌석에 따라 경우의 수가 결정됨
	
				//i + 1 숫자를 자유석에 배치하면서, i + 1 좌석을 사용하지 않은 경우
    	        dp[1][0][i + 1] += dp[0][0][i] + dp[0][1][i];

				//i + 1 숫자를 자유석에 배치하면서, i + 1 좌석을 사용한 경우
    	        dp[1][1][i + 1] += dp[0][2][i] + dp[0][3][i];
    	    }
	    }
	    
		//마지막 좌석이 자유석이면 마지막 전까지만 계산 됨
	    int end = k == n ? n - 1: n;

		//마지막은 다음 좌석이 없기 때문에 (end 기준으로 end + 1 좌석이 없음)
		//실제 경우의 수는 end + 1 좌석을 사용하지 않은 경우들만 더해야 함 
	    System.out.print(dp[0][0][end] + dp[0][1][end] + dp[1][0][end] + dp[1][1][end]);
	}
	
	static int nextInt() throws IOException {
	    st.nextToken();
	    return (int) st.nval;
	}
}