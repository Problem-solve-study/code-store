//제출번호: 93067203
//메모리:   11528 KB
//실행시간: 68 ms
import java.io.*;

//N이 10억이니까 O(N)의 풀이는 불가능
//6번째 라인을 호출할 때의 j를 쭉 확인해보면서 패턴을 찾아보려고 함

/*12을 예시로 들어봄
12에 대해서 i 마다 가능한 j 목록
1:	1 2 3 4 5 6 7 8 9 10 11 12 
2:	1 3 5 7 9 11
3:	1 4 7 10
4:	1 5 9
5:	1 6 11
6:	1 7
7:	1 8
8:	1 9
9:	1 10
10:	1 11
11:	1 12
12:	1

1은 모두 중복되니까 얘는 제외해봄
1:	2 3 4 5 6 7 8 9 10 11 12
2:	3 5 7 9 11
3:	4 7 10
4:	5 9
5:	6 11
6:	7
7:	8
8:	9
9:	10
10:	11
11:	12
12:

모든 숫자에 한 번 1을 모두 빼줌
1:	1 2 3 4 5 6 7 8 9 10 11
2:	2 4 6 8 10
3:	3 6 9
4:	4 8
5:	5 10
6:	6
7:	7
8:	8
9:	9
10:	10
11:	11
12:

여기서 잘 관찰해보니까 대각선 방향으로 대칭임을 알 수 있었음
대각선별로 몇 개 있는 지만 알면 계산하기 쉽겠네?
1 ~ 11 (+1 step)
4 ~ 10 (+2 step)
9 ~ 9 (+3 step)
방향으로 개수를 세면 중복없이 셀 수 있을 것 같았음
앞의 숫자는 제곱수이고, 뒤는 12보다 작은 수까지 임을 알 수 있음

각 step 별로 개수를 세는 모습을 보면
1 ~ 11 중 1의 배수의 개수 - 1 ~ (1 - 1) 중 1의 배수의 개수
4 ~ 11 중 2의 배수의 개수 - 1 ~ (4 - 1) 중 2의 배수의 개수
9 ~ 11 중 3의 배수의 개수 - 1 ~ (9 - 1) 중 3의 배수의 개수
로 계산이 됨

이 방법을 10억까지의 수로도 확장할 수 있고 잘 연산만 하면 됨

이 때 n이 1인 경우만 예외가 발생하므로 예외처리 해주면 됨 (1틀함)

추가로 7의 경우도 아래 적어둠
1:	1 2 3 4 5 6
2:	2 4 6
3:	3 6
4:	4
5:	5
6:	6
7:	
 */
public class Main {
    
    static StreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    
	public static void main(String[] args) throws IOException {
	    long n = nextInt();
	    
	    long res = n;
	    long cnt;
	    for (cnt = 1; cnt * cnt <= n; cnt++) {
			//1 ~ (n - 1) 수 중 cnt의 배수의 개수 - 1 ~ (cnt의 제곱 - 1) 수 중 cnt의 배수의 개수
	        long tmp = (n - 1) / cnt - (cnt * cnt - 1) / cnt;

			//수가 존재한다면
	        if (tmp != 0) {
				//가로, 세로 가 모두 같은 개수이므로 *2를 하고, 제곱수는 중복되었으므로 1을 빼줌
	            res += tmp * 2 - 1;
	        }
	    }
	    
	    System.out.print(res);
	}
	
	static int nextInt() throws IOException {
	    st.nextToken();
	    return (int) st.nval;
	}
}